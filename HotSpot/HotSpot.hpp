#pragma once

#include <cstdint>
#include <string>
#include <JNI/jni.h>

#define JVM_ACC_FIELD_INTERNAL 0x00000400
#define JVM_ACC_PUBLIC        0x0001  /* visible to everyone */
#define JVM_ACC_PRIVATE       0x0002  /* visible only to the defining class */
#define JVM_ACC_PROTECTED     0x0004  /* visible to subclasses */
#define JVM_ACC_STATIC        0x0008  /* instance variable is static */
#define JVM_ACC_FINAL         0x0010  /* no further subclassing, overriding */
#define JVM_ACC_SYNCHRONIZED  0x0020  /* wrap method call in monitor lock */
#define JVM_ACC_SUPER         0x0020  /* funky handling of invokespecial */
#define JVM_ACC_VOLATILE      0x0040  /* can not cache in registers */
#define JVM_ACC_BRIDGE        0x0040  /* bridge method generated by compiler */
#define JVM_ACC_TRANSIENT     0x0080  /* not persistent */
#define JVM_ACC_VARARGS       0x0080  /* method declared with variable number of args */
#define JVM_ACC_NATIVE        0x0100  /* implemented in C */
#define JVM_ACC_INTERFACE     0x0200  /* class is an interface */
#define JVM_ACC_ABSTRACT      0x0400  /* no definition provided */
#define JVM_ACC_STRICT        0x0800  /* strict floating point */
#define JVM_ACC_SYNTHETIC     0x1000  /* compiler-generated class, method or field */
#define JVM_ACC_ANNOTATION    0x2000  /* annotation type */
#define JVM_ACC_ENUM          0x4000  /* field is declared as element of enum */

namespace HotSpot
{
    typedef struct {
        const char* typeName;            // The type name containing the given field (example: "Klass")
        const char* fieldName;           // The field name within the type           (example: "_name")
        const char* typeString;          // Quoted name of the type of this field (example: "Symbol*";
        // parsed in Java to ensure type correctness
        int32_t  isStatic;               // Indicates whether following field is an offset or an address
        uint64_t offset;                 // Offset of field within structure; only used for nonstatic fields
        void* address;                   // Address of field; only used for static fields
        // ("offset" can not be reused because of apparent solstudio compiler bug
        // in generation of initializer data)
    } VMStructEntry;

    typedef struct {
        const char* typeName;            // Type name (example: "Method")
        const char* superclassName;      // Superclass name, or null if none (example: "oopDesc")
        int32_t isOopType;               // Does this type represent an oop typedef? (i.e., "Method*" or
        // "Klass*", but NOT "Method")
        int32_t isIntegerType;           // Does this type represent an integer type (of arbitrary size)?
        int32_t isUnsigned;              // If so, is it unsigned?
        uint64_t size;                   // Size, in bytes, of the type
    } VMTypeEntry;

    typedef struct {
        const char* name;                // Name of constant (example: "_thread_in_native")
        int32_t value;                   // Value of constant
    } VMIntConstantEntry;

    typedef struct {
        const char* name;                // Name of constant (example: "_thread_in_native")
        uint64_t value;                  // Value of constant
    } VMLongConstantEntry;

    typedef struct {
        const char* name;                // Name of address (example: "SharedRuntime::register_finalizer")
        void* value;                     // Value of address
    } VMAddressEntry;

    enum Flags {
        _caller_sensitive = 1 << 0,
        _force_inline = 1 << 1,
        _dont_inline = 1 << 2,
        _hidden = 1 << 3,
        _has_injected_profile = 1 << 4,
        _intrinsic_candidate = 1 << 5,
        _reserved_stack_access = 1 << 6,
        _scoped = 1 << 7
    };

    struct DirectoryEntry
    {
        DirectoryEntry* get_next();
        void* get_literal();
    };

    struct Dictionary
    {
        DirectoryEntry** get_buckets();
        int get_table_size();
    };

    struct Symbol
    {
        std::string to_string();
    };

    struct ConstantPool
    {
        void** get_base();
    };

    struct ConstMethod
    {
        ConstantPool* get_constants();
        unsigned short get_name_index();
        unsigned short get_signature_index();
    };

    struct AccessFlags
    {
        jint _flags;
        bool is_static();
    };

    struct Method
    {
        ConstMethod* get_constMethod();
        std::string get_signature();
        std::string get_name();
        int get_parameters_count();
        AccessFlags* get_access_flags();
        void* get_from_interpreted_entry();
        void set_from_interpreted_entry(void* entry);
        void* get_from_compiled_entry();
        void set_from_compiled_entry(void* entry);
    };

    struct Array
    {
        int get_length();
        void** get_data();
    };

    struct Array_u2
    {
        int get_length();
        unsigned short* get_data();
    };

    struct Thread
    {
        JNIEnv* get_env();
    };

    struct Klass
    {
        Symbol* get_name();
        Method* findMethod(const std::string& method_name, const std::string& method_sig);
        Array_u2* get_fields();
        Array* get_methods();
        ConstantPool* get_constants();
    };

    struct FieldInfo
    {
        unsigned short _data[6];
        unsigned short get_name_index();
        unsigned short get_signature_index();
        unsigned short get_access();
        bool is_internal();
        bool is_public();
        bool is_private();
        bool is_protected();
        bool is_static();
        bool is_final();
    };
};